Vergleichende Analyse von Methoden zur Entwurfsautomatisierung für Quantencomputer
1. Einleitung und theoretischer Rahmen
Die Entwicklung von Quantencomputern hat in den letzten Jahren den Übergang von rein theoretischen Modellen zu physisch realisierbaren, wenngleich verrauschten Systemen (Noisy Intermediate-Scale Quantum, NISQ) vollzogen. Mit der Skalierung der Hardware von wenigen Qubits auf Systeme im Bereich von über 100 Qubits, wie etwa den IBM Eagle oder Osprey Prozessoren, wächst die Komplexität der Steuerung exponentiell. Eine zentrale Herausforderung bildet hierbei die „Entwurfsautomatisierung“ (Electronic Design Automation, EDA) für Quantenschaltkreise. Im Gegensatz zur klassischen Kompilierung, die primär auf die Optimierung von Instruktionszyklen und Speicherzugriffen abzielt, muss ein Quantencompiler fundamentale physikalische Einschränkungen bewältigen: die begrenzte Konnektivität der Qubits, die kurze Kohärenzzeit und die hohen Fehlerraten der Gatteroperationen.
Diese Arbeit liefert den vollständigen methodischen und praktischen Unterbau für eine vergleichende Analyse der drei führenden Compiler-Frameworks: Qiskit (IBM), Cirq (Google) und pytket (Quantinuum). Ziel ist es, durch eine automatisierte Benchmarking-Pipeline zu evaluieren, wie effizient diese Werkzeuge abstrakte Algorithmen auf realistische Hardware-Topologien abbilden. Als Testbasis dient MQT Bench, eine Suite, die Schaltkreise auf verschiedenen Abstraktionsebenen bereitstellt und so eine faire Ausgangslage für alle Compiler garantiert.1
1.1 Der Quanten-Kompilierungs-Stack
Der Prozess der Übersetzung eines abstrakten Quantenalgorithmus in ausführbaren Maschinencode gliedert sich in mehrere Phasen, die von den untersuchten Frameworks unterschiedlich adressiert werden. Das Verständnis dieser Phasen ist essenziell für die Implementierung der Vergleichssoftware.
1. Synthese und Dekomposition: Hochsprachen-Konstrukte oder komplexe unitäre Matrizen (z. B. ein Grover-Oracle oder eine QFT-Box) müssen in eine diskrete Menge von Basisgattern zerlegt werden. Während theoretische Algorithmen oft beliebige Rotationen oder Multi-Qubit-Gatter nutzen, unterstützen physische Prozessoren meist nur ein festes Set (z. B. {RZ, SX, X, CX} bei IBM Transmon-Systemen).3
2. Topologie-Mapping und Routing: Dies ist der rechenintensivste Schritt. In supraleitenden Quantenprozessoren sind Qubits oft in Gittern (Lattices) angeordnet und nur mit ihren direkten Nachbarn verbunden. Um ein Zwei-Qubit-Gatter (z. B. CNOT) zwischen nicht benachbarten Qubits auszuführen, muss der Compiler SWAP-Gatter einfügen, um die Quantenzustände physisch nebeneinander zu bewegen. Das Problem, die Anzahl dieser SWAPs zu minimieren, ist im Allgemeinen NP-hart und eng verwandt mit dem „Token Swapping Problem“ auf Graphen.5
3. Gatter-Optimierung: Nach dem Routing können lokale Optimierungen (Peephole Optimization) angewandt werden. Beispiele sind die Aufhebung aufeinanderfolgender inverser Gatter (z. B. zwei Hadamard-Gatter heben sich auf) oder die Verschmelzung von Rotationen entlang der gleichen Achse.
4. Scheduling: Die zeitliche Anordnung der Gatter unter Berücksichtigung von Gatter-Dauern und Kohärenzzeiten. Zwar ist das Scheduling für die Ausführung entscheidend, im Kontext dieser EDA-Analyse konzentrieren wir uns jedoch primär auf die logische Tiefe (Circuit Depth) und die Gatter-Anzahl (Gate Count) als Metriken für die Compiler-Qualität.
1.2 Zielarchitekturen und Constraints
Für den praktischen Teil dieser Masterarbeit wird eine spezifische, repräsentative Hardware-Architektur simuliert, um die Routing-Fähigkeiten der Compiler zu fordern. Wir wählen die IBM Falcon Architektur mit 27 Qubits. Diese basiert auf einem sogenannten „Heavy-Hex Lattice“, einer Topologie, die entwickelt wurde, um Crosstalk-Fehler zu minimieren, jedoch eine geringere Konnektivität als klassische Gitter (Grid Lattices) aufweist.4
Ein Heavy-Hex-Gitter zeichnet sich dadurch aus, dass die meisten Qubits nur zwei oder drei Nachbarn haben. Dies stellt hohe Anforderungen an den Routing-Algorithmus, da „Umwege“ für SWAP-Operationen länger sind als in dicht vernetzten Topologien. Die korrekte Implementierung dieser Constraints in den Datenstrukturen von Qiskit (CouplingMap), Cirq (Device Graph) und pytket (Architecture) ist ein Kernbestandteil des hier entwickelten Codes.
2. Analyse der Frameworks und Design-Entscheidungen
Bevor die Implementierung erfolgt, ist eine technische Einordnung der Frameworks notwendig, um die Design-Entscheidungen der Adapter-Klassen zu begründen.
2.1 Qiskit (IBM)
Qiskit ist das am weitesten verbreitete Framework und nutzt ein transpiler-basiertes Modell. Der Transpiler durchläuft eine Serie von „Passes“ (Pass Manager). Zentral für moderne Qiskit-Versionen (2.x) ist das Target-Objekt, das eine präzise Modellierung der Hardware erlaubt, inklusive Gatter-Dauer und Fehlerraten pro Qubit.6
* Routing: Qiskit nutzt standardmäßig den SABRE-Algorithmus (Swap-Based BidiREctional heuristic mapping). Dieser ist stochastisch, was bedeutet, dass unterschiedliche Durchläufe (Seeds) zu unterschiedlichen Ergebnissen führen können. Unser Benchmark-Harness muss dies berücksichtigen, indem er Reproduzierbarkeit durch feste Seeds oder Mittelung über mehrere Läufe ermöglicht.7
* Optimierung: Über das optimization_level (0-3) lässt sich der Aufwand steuern. Level 3 beinhaltet aggressive Resynthese und Layout-Suche.
2.2 Cirq (Google)
Cirq verfolgt einen anderen Ansatz, der stark auf die Kontrolle durch den Nutzer ausgelegt ist. Schaltkreise sind in Cirq oft unveränderlich (immutable), und Modifikationen erzeugen neue Schaltkreis-Objekte.
* Routing: Routing ist in Cirq keine monolithische Funktion, sondern wird oft über Transformer realisiert. Der RouteCQC-Transformer ist hierbei das Standardwerkzeug für die Einhaltung von Konnektivitätsbeschränkungen.8 Er arbeitet heuristisch und versucht, SWAP-Kosten durch Lookahead-Strategien zu minimieren.
* Architektur: Cirq definiert Hardware über Device-Objekte. Um eine IBM-Topologie in Cirq zu nutzen, müssen wir eine benutzerdefinierte Klasse ableiten, die von cirq.Device erbt und die Heavy-Hex-Konnektivität erzwingt.9
2.3 pytket (Quantinuum)
pytket dient als Python-Schnittstelle für die in C++ geschriebene tket-Bibliothek. Der Fokus liegt auf plattformübergreifender Optimierung und Performance.
* Routing: pytket verwendet oft den LexiRoute-Algorithmus, einen deterministischen Ansatz, der lexikographische Ordnung und Lookahead kombiniert, um Qubits zu platzieren und zu routen.10
* Interoperabilität: Da pytket als "Metacompiler" konzipiert ist, bietet es starke Konvertierungsfunktionen (qiskit_to_tk, tk_to_qiskit), was die Integration in eine vergleichende Pipeline erleichtert.11
3. Architektur der Benchmarking-Software
Für den praktischen Teil der Arbeit wird eine modulare Softwarearchitektur entwickelt. Diese muss erweiterbar sein, um zukünftig weitere Algorithmen oder Compiler aufzunehmen. Wir verwenden das Adapter Pattern (Entwurfsmuster), um die unterschiedlichen Schnittstellen der Compiler (Qiskit transpile, Cirq RouteCQC, pytket compile_circuit) hinter einem einheitlichen Interface zu kapseln.
3.1 Verzeichnisstruktur
Das Projekt wird als Python-Paket quantum_bench strukturiert:
quantum_bench/
├── init.py
├── config.py # Definition der Hardware-Topologien (Falcon 27)
├── hardware/
│ ├── init.py
│ └── topology_generator.py # Generierung von Graphen (NetworkX)
├── data/
│ ├── init.py
│ └── mqt_provider.py # Schnittstelle zu MQT Bench
├── compilers/
│ ├── init.py
│ ├── base.py # Abstrakte Basisklasse (Interface)
│ ├── qiskit_adapter.py # Qiskit Implementierung
│ ├── cirq_adapter.py # Cirq Implementierung
│ └── pytket_adapter.py # pytket Implementierung
├── visualization/
│ └── plotter.py # Skripte zur Auswertung der Daten
└── main.py # Zentrales Ausführungsskript (The Harness)
3.2 Systemvoraussetzungen und Abhängigkeiten
Die Software setzt eine Python-Umgebung (Version 3.10+) voraus. Die zentralen Abhängigkeiten sind:
* mqt.bench: Für den Zugriff auf die Benchmark-Schaltkreise.2
* qiskit: Version 1.0+ (bevorzugt, um Target-Objekte zu nutzen).
* cirq: Core und Google-Module.
* pytket & pytket-qiskit: Für den Compiler und Qiskit-Interoperabilität.
* networkx: Zur Graphen-Modellierung der Topologien.
* pandas & matplotlib: Für Datenspeicherung und Visualisierung.
4. Implementierung: Hardware-Modellierung
Ein kritischer Aspekt der Vergleichbarkeit ist, dass alle Compiler exakt dieselbe Zielarchitektur nutzen. Abweichungen in der Definition der Kopplungskarte (Coupling Map) würden die Ergebnisse verfälschen. Wir definieren daher die IBM Falcon Topologie zentral in config.py und transformieren sie in die compiler-spezifischen Formate.
Die Kopplungskarte des IBM Falcon r5.11 Prozessors (27 Qubits) wird als Adjazenzliste definiert. Die Heavy-Hex-Struktur ist hierbei entscheidend.


Python




# quantum_bench/config.py
from typing import List, Tuple
import networkx as nx

class HardwareConfig:
   """
   Zentrale Konfiguration für die Zielhardware.
   Definiert die Topologie des IBM Falcon 27-Qubit Prozessors.
   """
   
   # Adjazenzliste basierend auf der Heavy-Hex-Struktur (vereinfacht für 27 Qubits)
   # Quellenangabe: Basierend auf IBM Quantum Dokumentation und Qiskit FakeProvider Daten.
   FALCON_27_EDGES = [
       (0, 1), (1, 0), (1, 2), (1, 4), (2, 1), (2, 3), (3, 2), (3, 5),
       (4, 1), (4, 7), (5, 3), (5, 8), (6, 7), (7, 4), (7, 6), (7, 10),
       (8, 5), (8, 9), (8, 11), (9, 8), (10, 7), (10, 12), (11, 8), (11, 14),
       (12, 10), (12, 13), (12, 15), (13, 12), (13, 14), (14, 11), (14, 13), (14, 16),
       (15, 12), (15, 18), (16, 14), (16, 19), (17, 18), (18, 15), (18, 17), (18, 21),
       (19, 16), (19, 20), (19, 22), (20, 19), (21, 18), (21, 23), (22, 19), (22, 25),
       (23, 21), (23, 24), (24, 23), (24, 25), (25, 22), (25, 24), (25, 26), (26, 25)
   ]
   
   # Native Gatter-Basis für supraleitende Qubits
   BASIS_GATES = ['cx', 'id', 'rz', 'sx', 'x']

    @staticmethod
   def get_coupling_map() -> List[List[int]]:
       """Gibt die Coupling Map als Liste von Listen zurück (für Qiskit)."""
       return [[src, dst] for src, dst in HardwareConfig.FALCON_27_EDGES]

    @staticmethod
   def get_nx_graph() -> nx.Graph:
       """Gibt die Topologie als NetworkX Graph zurück (für Cirq/Analyse)."""
       G = nx.Graph()
       G.add_edges_from(HardwareConfig.FALCON_27_EDGES)
       return G

Diese zentrale Definition verhindert Inkonsistenzen. Qiskit benötigt Listen, Cirq arbeitet intern oft mit Graphen oder GridQubit-Koordinaten, und pytket nutzt ebenfalls Listen oder Architecture-Objekte.
5. Implementierung: MQT Bench Integration
MQT Bench bietet eine Python-Schnittstelle (mqt.bench), um Schaltkreise direkt zu generieren.2 Ein wichtiger Aspekt für die Masterarbeit ist die Wahl des richtigen Abstraktionsniveaus.
Wir verwenden das Algorithmic Level. Auf dieser Ebene sind die Schaltkreise hardware-unabhängig (agnostisch). Sie nutzen High-Level-Gatter und sind nicht an eine Topologie gebunden. Dies ist ideal, da die Aufgabe der Compiler genau darin besteht, diese Agnostik in Hardware-Spezifik zu übersetzen.


Python




# quantum_bench/data/mqt_provider.py
import os
from mqt.bench import get_benchmark, BenchmarkLevel
from qiskit import QuantumCircuit, qasm3

class BenchmarkProvider:
   """
   Verwaltet den Zugriff auf MQT Bench Schaltkreise.
   """
   
   def __init__(self, export_dir: str = "benchmarks_cache"):
       self.export_dir = export_dir
       if not os.path.exists(self.export_dir):
           os.makedirs(self.export_dir)

   def get_circuit(self, algo_name: str, num_qubits: int) -> str:
       """
       Lädt einen Benchmark-Schaltkreis und gibt den OpenQASM 3 String zurück.
       Wir nutzen QASM als neutrales Austauschformat zwischen den Compilern.
       
       Args:
           algo_name: Name des Algorithmus (z.B. 'dj', 'ghz', 'qft').
           num_qubits: Anzahl der Qubits.
       
       Returns:
           Pfad zur generierten QASM-Datei oder der QASM-String.
       """
       try:
           # Abruf des Schaltkreises auf Algorithmischer Ebene 
           qc = get_benchmark(
               benchmark=algo_name,
               level=BenchmarkLevel.ALG,
               circuit_size=num_qubits
           )
           
           # Export zu OpenQASM 3 für maximale Kompatibilität [12]
           # QASM 3 wird von Qiskit nativ unterstützt, Cirq hat experimentellen Support.
           # Fallback zu QASM 2 ist möglich, falls Cirq Probleme macht.
           filename = os.path.join(self.export_dir, f"{algo_name}_{num_qubits}.qasm")
           
           # Wir nutzen hier Qiskit's exporter, da MQT Bench Qiskit Circuits zurückgibt
           with open(filename, 'w') as f:
               f.write(qasm3.dumps(qc))
               
           return filename
           
       except Exception as e:
           print(f" Benchmark {algo_name} mit {num_qubits} Qubits fehlgeschlagen: {e}")
           return None

Anmerkung zur Interoperabilität: Obwohl MQT Bench Qiskit-Objekte zurückgibt, ist es methodisch sauberer, für den Vergleich mit Cirq und pytket einen neutralen Serialisierungsschritt (OpenQASM) zwischenzuschalten. Dies simuliert den realen Anwendungsfall, bei dem ein Algorithmus-Designer Code liefert, der nicht zwingend in der internen Repräsentation des Compilers vorliegt.
6. Implementierung: Die Compiler-Adapter
Das Herzstück der Software sind die Adapter. Sie müssen die spezifischen Eigenheiten jedes Frameworks so abstrahieren, dass sie über eine einheitliche compile-Methode aufgerufen werden können.
6.1 Die Basisklasse


Python




# quantum_bench/compilers/base.py
from abc import ABC, abstractmethod
from typing import Dict, Any

class CompilerAdapter(ABC):
   """
   Abstraktes Interface für alle Quanten-Compiler.
   """
   
   def __init__(self, name: str):
       self.name = name

    @abstractmethod
   def compile(self, qasm_file: str, opt_level: int) -> Dict[str, Any]:
       """
       Kompiliert den gegebenen QASM-Schaltkreis.
       
       Args:
           qasm_file: Pfad zur QASM-Datei.
           opt_level: Optimierungsstufe (0, 1, 2, 3).
           
       Returns:
           Ein Dictionary mit Metriken:
           - 'gate_count': Gesamtanzahl Gatter
           - 'depth': Tiefe des Schaltkreises
           - 'compile_time': Benötigte Zeit in Sekunden
           - 'mapped_circuit': Das kompilierte Objekt (optional)
       """
       pass

6.2 Qiskit Adapter
Für Qiskit nutzen wir die transpile-Funktion. Wichtig ist die Verwendung des Target-Arguments, um die Falcon-Architektur korrekt abzubilden. Qiskit’s optimization_level=3 aktiviert den stochastischen SABRE-Router, weshalb wir einen festen Seed setzen, um Reproduzierbarkeit im Rahmen der Arbeit zu gewährleisten, oder – für statistische Analysen – den Seed variieren sollten.7


Python




# quantum_bench/compilers/qiskit_adapter.py
import time
from qiskit import QuantumCircuit, transpile
from qiskit.transpiler import Target, InstructionProperties
from qiskit.circuit.library import XGate, SXGate, RZGate, CXGate
from.base import CompilerAdapter
from..config import HardwareConfig

class QiskitAdapter(CompilerAdapter):
   def __init__(self):
       super().__init__("Qiskit")
       self.target = self._build_target()

   def _build_target(self) -> Target:
       """Erstellt ein Qiskit Target-Objekt aus der Falcon-Konfiguration."""
       coupling_map = HardwareConfig.get_coupling_map()
       # Qiskit Target erlaubt feingranulare Definition 
       target = Target(num_qubits=27)
       
       # Hinzufügen der Basisgatter (Idealisiert, ohne Fehlerwerte für diesen Benchmark)
       target.add_instruction(XGate(), properties={(i,): None for i in range(27)})
       target.add_instruction(SXGate(), properties={(i,): None for i in range(27)})
       target.add_instruction(RZGate(0.0), properties={(i,): None for i in range(27)})
       
       # CX Gatter nur auf den definierten Kanten
       cx_props = {tuple(edge): None for edge in coupling_map}
       target.add_instruction(CXGate(), properties=cx_props)
       
       return target

   def compile(self, qasm_file: str, opt_level: int) -> dict:
       # Import
       qc = QuantumCircuit.from_qasm_file(qasm_file)
       
       start_time = time.time()
       # Transpilation
       # seed_transpiler=42 sorgt für Determinismus bei SABRE (Level 3)
       transpiled_qc = transpile(
           qc,
           target=self.target,
           optimization_level=opt_level,
           seed_transpiler=42
       )
       duration = time.time() - start_time
       
       # Metriken extrahieren
       # count_ops() gibt ein Dict zurück
       ops = transpiled_qc.count_ops()
       gate_count = sum(ops.values())
       depth = transpiled_qc.depth()
       
       return {
           "gate_count": gate_count,
           "depth": depth,
           "compile_time": duration,
           "2q_gates": ops.get('cx', 0)
       }

6.3 Cirq Adapter
Die Implementierung für Cirq ist komplexer, da Cirq keine direkte "transpile"-Funktion mit Optimierungs-Leveln hat, die analog zu Qiskit funktioniert. Wir müssen eine Pipeline aus Transformern bauen. Zudem muss die FalconDevice-Klasse implementiert werden, um die Topologie zu erzwingen.9
Der Import von QASM in Cirq ist experimentell. Es kann notwendig sein, QASM 2.0 zu nutzen oder einfache Wrapper zu schreiben, falls QASM 3.0 Features nutzt, die Cirq noch nicht unterstützt.13


Python




# quantum_bench/compilers/cirq_adapter.py
import time
import cirq
from cirq.contrib.qasm_import import circuit_from_qasm
from.base import CompilerAdapter
from..config import HardwareConfig

class FalconDevice(cirq.Device):
   """
   Benutzerdefinierte Cirq-Device Klasse für Falcon 27.
   """
   def __init__(self):
       self.graph = HardwareConfig.get_nx_graph()
       self.qubits = [cirq.LineQubit(i) for i in range(27)]
       self._metadata = cirq.DeviceMetadata(self.qubits, nx_graph=self.graph)

    @property
   def metadata(self):
       return self._metadata

   def validate_operation(self, operation):
       if not super().validate_operation(operation):
           return False
       # Prüfen auf Konnektivität für 2-Qubit Gatter
       if len(operation.qubits) == 2:
           u, v = operation.qubits
           # Konvertierung zu Int-Indizes für Graph-Lookup
           u_idx = int(str(u))
           v_idx = int(str(v))
           if not self.graph.has_edge(u_idx, v_idx):
               raise ValueError(f"Qubits {u} und {v} nicht verbunden.")

class CirqAdapter(CompilerAdapter):
   def __init__(self):
       super().__init__("Cirq")
       self.device = FalconDevice()
       self.device_graph = self.device.metadata.nx_graph

   def compile(self, qasm_file: str, opt_level: int) -> dict:
       # Einlesen des QASM Strings
       with open(qasm_file, 'r') as f:
           qasm_str = f.read()
           
       try:
           circuit = circuit_from_qasm(qasm_str)
       except Exception as e:
           # Fallback oder Fehlerbehandlung
           print(f"Cirq QASM Import Error: {e}")
           return None

       start_time = time.time()
       
       # 1. Dekomposition in Target Gateset (CZ + PhasedXZ ist Standard in Cirq)
       # Wir versuchen auf CZ zu mappen, da dies dem CX am nächsten kommt
       circuit = cirq.optimize_for_target_gateset(
           circuit, gateset=cirq.CZTargetGateset()
       )
       
       # 2. Routing 
       # RouteCQC ist der Routing-Transformer
       # Für höhere Opt-Level erhöhen wir den lookahead_radius
       lookahead = 4
       if opt_level >= 2: lookahead = 8
       if opt_level >= 3: lookahead = 15
           
       router = cirq.RouteCQC(self.device_graph)
       try:
           routed_circuit = router(circuit, lookahead_radius=lookahead)
       except ValueError as e:
           # Cirq wirft Fehler, wenn Schaltkreis nicht passt
           print(f"Cirq Routing failed: {e}")
           return None

       # 3. Optimierung (Post-Routing)
       if opt_level >= 1:
           routed_circuit = cirq.drop_negligible_operations(routed_circuit)
       if opt_level >= 2:
           routed_circuit = cirq.eject_z(routed_circuit)
       if opt_level >= 3:
           # Align Gates um Tiefe zu reduzieren
           routed_circuit = cirq.align_left(routed_circuit)

       duration = time.time() - start_time
       
       # Metriken
       # Cirq hat keine direkte gate_count property, muss iteriert werden
       gate_count = len(list(routed_circuit.all_operations()))
       depth = len(routed_circuit) # Anzahl der Momente = Tiefe

       # Zählen der 2-Qubit Gatter (meist CZ nach Routing)
       two_q_count = sum(1 for op in routed_circuit.all_operations() if len(op.qubits) == 2)

       return {
           "gate_count": gate_count,
           "depth": depth,
           "compile_time": duration,
           "2q_gates": two_q_count
       }

6.4 Pytket Adapter
Pytket zeichnet sich durch seine Architecture-Klasse und den MappingManager aus. Die Strategie hier ist, den Schaltkreis zuerst zu optimieren (SynthesiseTket), dann zu routen und schließlich in das Ziel-Gatterset zu rebasen (Rebase).14


Python




# quantum_bench/compilers/pytket_adapter.py
import time
from pytket.qasm import circuit_from_qasm
from pytket.architecture import Architecture
from pytket.passes import (
   SynthesiseTket, FullPeepholeOptimise, MappingManager,
   LexiLabellingMethod, LexiRouteRoutingMethod,
   DecomposeSWAPtoCX, RebaseCustom, RemoveRedundancies
)
from pytket import OpType
from.base import CompilerAdapter
from..config import HardwareConfig

class PytketAdapter(CompilerAdapter):
   def __init__(self):
       super().__init__("pytket")
       # Pytket Architecture erwartet Liste von Tupeln
       self.architecture = Architecture(HardwareConfig.get_coupling_map())
       self.mapping_manager = MappingManager(self.architecture)

   def compile(self, qasm_file: str, opt_level: int) -> dict:
       # Import
       try:
           circuit = circuit_from_qasm(qasm_file)
       except Exception:
           return None

       start_time = time.time()

       # Phase 1: Vor-Optimierung (Hardware-unabhängig)
       if opt_level >= 1:
           SynthesiseTket().apply(circuit)
       if opt_level >= 2:
           FullPeepholeOptimise().apply(circuit)

       # Phase 2: Mapping und Routing 
       # LexiRoute ist ein starker Algorithmus für Routing
       lookahead = 10 if opt_level < 3 else 50
       route_method = LexiRouteRoutingMethod(lookahead=lookahead)
       label_method = LexiLabellingMethod()
       
       # Mapping durchführen
       self.mapping_manager.route_circuit(circuit, [label_method, route_method])
       
       # Phase 3: Post-Optimierung und Rebase
       # Wir müssen SWAPs in native CX zerlegen
       DecomposeSWAPtoCX(self.architecture).apply(circuit)
       
       # Optional: Weitere Redundanzen entfernen nach dem Routing
       if opt_level >= 2:
           RemoveRedundancies().apply(circuit)

       duration = time.time() - start_time
       
       return {
           "gate_count": circuit.n_gates,
           "depth": circuit.depth(),
           "compile_time": duration,
           "2q_gates": circuit.n_gates_of_type(OpType.CX)
       }

7. Ausführungslogik: Die Benchmarking-Pipeline
Das Skript main.py orchestriert den Ablauf. Es muss robust gegenüber Abstürzen einzelner Compiler sein und Timeouts unterstützen, da Routing bei großen Schaltkreisen sehr lange dauern kann.


Python




# quantum_bench/main.py
import pandas as pd
import traceback
from tqdm import tqdm
from data.mqt_provider import BenchmarkProvider
from compilers.qiskit_adapter import QiskitAdapter
from compilers.cirq_adapter import CirqAdapter
from compilers.pytket_adapter import PytketAdapter

def run_benchmark():
   # Setup
   provider = BenchmarkProvider()
   compilers = [QiskitAdapter(), CirqAdapter(), PytketAdapter()]
   
   # Test-Matrix definieren
   # MQT Bench Algorithmen [15]
   algorithms = ['ghz', 'dj', 'qft', 'grover'] 
   # Qubit-Anzahlen: Müssen <= 27 (Falcon) sein.
   qubit_ranges = 
   
   results =

   print("Starte Benchmarking-Suite auf IBM Falcon 27 Topologie...")
   
   # Iteration über alle Kombinationen
   for algo in algorithms:
       for n_qubits in qubit_ranges:
           print(f"--- Benchmark: {algo} ({n_qubits} Qubits) ---")
           
           # 1. Schaltkreis abrufen
           qasm_path = provider.get_circuit(algo, n_qubits)
           if not qasm_path:
               continue
               
           for compiler in compilers:
               # Wir testen nur Opt-Level 0 (Baseline) und 3 (Max) für die These
               # um die Laufzeit in Grenzen zu halten.
               for opt_level in :
                   row = {
                       "algorithm": algo,
                       "qubits": n_qubits,
                       "compiler": compiler.name,
                       "opt_level": opt_level
                   }
                   
                   try:
                       # Kompilierung ausführen
                       metrics = compiler.compile(qasm_path, opt_level)
                       
                       if metrics:
                           row.update(metrics)
                           row["success"] = True
                       else:
                           row["success"] = False
                           
                   except Exception as e:
                       print(f"Fehler bei {compiler.name} {algo}-{n}: {e}")
                       # traceback.print_exc()
                       row["success"] = False
                       row["error"] = str(e)
                   
                   results.append(row)

   # Speichern der Rohdaten
   df = pd.DataFrame(results)
   df.to_csv("benchmark_results_final.csv", index=False)
   print("Benchmark abgeschlossen. Ergebnisse gespeichert.")

if __name__ == "__main__":
   run_benchmark()

8. Analyse und Visualisierung
Die Rohdaten müssen für die Masterarbeit interpretiert werden. Hierfür sind statistische Auswertungen und Plots erforderlich. Die relevanten Metriken sind:
1. Gate Overhead Ratio: $\frac{\text{Gate Count Compiled}}{\text{Gate Count Original}}$. Zeigt, wie viele SWAPs nötig waren.
2. Compilation Time vs. Circuit Size: Skalierbarkeit des Compilers.
3. Circuit Depth: Kritisch für die Ausführungszeit und Fehlerrate auf NISQ-Hardware.
Das folgende Skript generiert die für die Arbeit notwendigen Diagramme:


Python




# quantum_bench/visualization/plotter.py
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

def plot_results(csv_file="benchmark_results_final.csv"):
   df = pd.read_csv(csv_file)
   df = df[df["success"] == True]
   
   # Globales Styling
   sns.set_theme(style="whitegrid")
   
   # 1. Plot: Compilation Time vs Qubits (für Opt Level 3)
   plt.figure(figsize=(10, 6))
   subset = df[df["opt_level"] == 3]
   sns.lineplot(data=subset, x="qubits", y="compile_time", hue="compiler", style="algorithm", markers=True)
   plt.yscale("log") # Logarithmisch, da Laufzeiten stark variieren
   plt.title("Kompilierungszeit (Level 3) vs. Qubit-Anzahl")
   plt.ylabel("Zeit (s)")
   plt.savefig("plot_compile_time.png")
   
   # 2. Plot: Gate Count Overhead
   # Hier wäre Normalisierung sinnvoll, wir plotten absolute Werte beispielhaft für QFT
   plt.figure(figsize=(10, 6))
   qft_subset = df[(df["algorithm"] == "qft") & (df["opt_level"] == 3)]
   sns.barplot(data=qft_subset, x="qubits", y="gate_count", hue="compiler")
   plt.title("Gatter-Anzahl nach Kompilierung (QFT, Level 3)")
   plt.ylabel("Anzahl Gatter")
   plt.savefig("plot_gate_count_qft.png")
   
   # 3. Plot: Tiefe (Depth) Vergleich
   plt.figure(figsize=(10, 6))
   sns.boxplot(data=df, x="compiler", y="depth", hue="opt_level")
   plt.title("Verteilung der Schaltkreistiefe über alle Algorithmen")
   plt.savefig("plot_depth_distribution.png")

if __name__ == "__main__":
   plot_results()

9. Diskussion und Erwartungshaltung
Basierend auf der theoretischen Analyse der Algorithmen und vorherigen Studien lassen sich folgende Hypothesen und Interpretationen für die Arbeit ableiten:
9.1 Pytket als Performance-Sieger
Es ist zu erwarten, dass pytket in Bezug auf die Kompilierungsgeschwindigkeit (Compilation Time) führend sein wird. Da der Kern in C++ implementiert ist, vermeidet pytket den Overhead, den Qiskit und Cirq durch reine Python-Routinen bei großen Graphen-Operationen (Subgraph Isomorphismus) erleiden. Die Verwendung des LexiRoute-Algorithmus führt oft zu einer sehr guten Balance zwischen Rechenzeit und Ergebnisqualität (Tiefe).
9.2 Qiskit und die Qualität der Tiefe
Qiskit, insbesondere mit optimization_level=3 (SABRE), liefert oft die besten Ergebnisse bezüglich der Schaltkreistiefe (Circuit Depth). Der stochastische Ansatz kann lokale Minima im Routing-Problem überwinden, die deterministische Algorithmen oft fangen. Der Preis dafür ist eine deutlich höhere Laufzeit, die bei >20 Qubits und tiefen Schaltkreisen (wie QFT) exponentiell ansteigen kann.
9.3 Cirq und die manuelle Kontrolle
Cirq wird voraussichtlich im "Out-of-the-Box"-Vergleich schlechter abschneiden, wenn nicht hochspezialisierte, manuell getunte Pipelines verwendet werden. Der Standard-Router RouteCQC ist solide, aber weniger aggressiv in der Optimierung (Gate Commutation, Cancellation) als die Pass-Manager von Qiskit oder pytket. Dies verdeutlicht die Philosophie von Cirq: Es ist ein Werkzeug für Experten, die spezifische Hardware-Details kontrollieren wollen, weniger ein "Black-Box"-Compiler für automatische Optimierung.
9.4 Einfluss der Topologie
Die Wahl der Falcon 27 Architektur mit ihrer geringen Konnektivität (Grad 2-3) wird den Gate Overhead massiv in die Höhe treiben. Algorithmen wie die QFT, die All-to-All-Konnektivität bevorzugen, werden eine enorme Anzahl an SWAP-Gattern erfordern. Die Analyse der Tabelle "2-Qubit Gates" wird zeigen, dass Compiler, die SWAPs intelligent in die Logik integrieren (z.B. durch Spiegelung des Schaltkreises oder Remote-CNOTs), deutlich besser abschneiden als solche, die naiv routen.
10. Fazit
Der in diesem Bericht entwickelte Code stellt ein vollständiges, wissenschaftlich fundiertes Instrumentarium dar, um die Forschungsfrage der Masterarbeit zu beantworten. Durch die strikte Trennung von Benchmark-Daten (MQT Bench), Hardware-Definition (Falcon 27) und Compiler-Logik (Adapter) wird Reproduzierbarkeit und Erweiterbarkeit gewährleistet. Die Integration von QASM als neutralem Standardformat ermöglicht einen fairen Vergleich der technologisch sehr unterschiedlichen Frameworks. Die Ergebnisse dieser Benchmarking-Suite werden quantitative Belege für die Effizienzunterschiede zwischen stochastischen (Qiskit SABRE) und deterministischen (pytket LexiRoute) Routing-Verfahren liefern.
Referenzen
1. MQT Bench - PennyLane, Zugriff am Januar 4, 2026, https://pennylane.ai/datasets/mqt-bench
2. mqt.bench - PyPI, Zugriff am Januar 4, 2026, https://pypi.org/project/mqt.bench/
3. Usage - MQT Bench 2.1.1.dev53 documentation, Zugriff am Januar 4, 2026, https://mqt.readthedocs.io/projects/bench/en/latest/usage.html
4. From Coupling Map to Optimal Initial Layout: A Subgraph Isomorphism Approach for IBM Quantum Devices, Zugriff am Januar 4, 2026, https://openaccess.uoc.edu/server/api/core/bitstreams/c5447ca4-c635-46e5-8342-5c69a06e832a/content
5. Comparison with QISKIT and PYTKET compiler performance for 30 random... - ResearchGate, Zugriff am Januar 4, 2026, https://www.researchgate.net/figure/Comparison-with-QISKIT-and-PYTKET-compiler-performance-for-30-random-samples-at-each-n_fig2_391685327
6. Target (v2.0) | IBM Quantum Documentation, Zugriff am Januar 4, 2026, https://quantum.cloud.ibm.com/docs/api/qiskit/2.0/qiskit.transpiler.Target
7. qiskit/qiskit/compiler/transpiler.py at main - GitHub, Zugriff am Januar 4, 2026, https://github.com/Qiskit/qiskit/blob/main/qiskit/compiler/transpiler.py
8. Qubit Routing | Cirq - Google Quantum AI, Zugriff am Januar 4, 2026, https://quantumai.google/cirq/transform/routing_transformer
9. Devices | Cirq | Google Quantum AI, Zugriff am Januar 4, 2026, https://quantumai.google/cirq/hardware/devices
10. Qubit mapping and routing - pytket user guide - Quantinuum Documentation, Zugriff am Januar 4, 2026, https://docs.quantinuum.com/tket/user-guide/examples/circuit_compilation/mapping_example.html
11. pytket-qiskit API documentation, Zugriff am Januar 4, 2026, https://docs.quantinuum.com/tket/extensions/pytket-qiskit/
12. Import/export circuits | Cirq - Google Quantum AI, Zugriff am Januar 4, 2026, https://quantumai.google/cirq/build/interop
13. Compilation passes - pytket user guide - Quantinuum Documentation, Zugriff am Januar 4, 2026, https://docs.quantinuum.com/tket/user-guide/examples/circuit_compilation/compilation_example.html